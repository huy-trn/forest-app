name: Deploy to EC2

on:
  push:
    branches:
      - main

env:
  IMAGE_NAME: ghcr.io/${{ github.repository }}

jobs:
  changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      build: ${{ steps.filter.outputs.build }}
      deploy: ${{ steps.filter.outputs.deploy }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - id: filter
        name: Check changed paths
        uses: dorny/paths-filter@v3
        with:
          filters: |
            build:
              - 'app/**'
              - 'components/**'
              - 'lib/**'
              - 'prisma/**'
              - 'styles/**'
              - 'public/**'
              - 'next.config.*'
              - 'package.json'
              - 'package-lock.json'
              - 'tsconfig.json'
              - 'Dockerfile'
              - '.dockerignore'
            deploy:
              - 'docker-compose.yml'
              - 'docker-compose.prod.yml'
              - 'deploy/**'
              - '.github/workflows/**'
  build-and-push:
    name: Build and push image
    runs-on: ubuntu-latest
    needs: changes
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v5
        if: needs.changes.outputs.build == 'true'
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy on EC2 via SSH
    runs-on: ubuntu-latest
    needs: [changes, build-and-push]
    if: (needs.changes.outputs.deploy == 'true' || needs.changes.outputs.build == 'true') && needs.build-and-push.result != 'failure'
    timeout-minutes: 180
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate deploy artifacts exist
        run: |
          set -e
          ls -l docker-compose.yml docker-compose.prod.yml deploy/nginx/app.conf.tmpl deploy/scripts/seed.sh

      - name: Upload compose, nginx template, and scripts
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: ./docker-compose.yml,./docker-compose.prod.yml,./deploy/nginx/app.conf.tmpl,./deploy/scripts/seed.sh
          target: /home/${{ secrets.EC2_USER }}/app

      - name: Deploy using docker compose
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          command_timeout: 7200
          envs: IMAGE_NAME,IMAGE_TAG,GHCR_USERNAME,GHCR_TOKEN,DOMAIN_NAME,CERTBOT_EMAIL,EC2_HOST
          script: |
            set -e
            APP_DIR="/home/${{ secrets.EC2_USER }}/app"
            mkdir -p "$APP_DIR"
            cd "$APP_DIR"

            ensure_docker() {
              if command -v docker >/dev/null 2>&1; then return; fi
              echo "Docker not found. Detecting distro and installing..."
              os_release="/etc/os-release"
              is_amazon="false"
              if [ -f "$os_release" ] && grep -qi "amazon linux" "$os_release"; then
                is_amazon="true"
              fi

              if [ "$is_amazon" = "true" ]; then
                echo "Installing Docker for Amazon Linux..."
                if command -v yum >/dev/null 2>&1; then
                  sudo yum update -y
                fi
                if command -v amazon-linux-extras >/dev/null 2>&1; then
                  sudo amazon-linux-extras install docker -y
                else
                  sudo yum install -y docker
                fi
                if command -v systemctl >/dev/null 2>&1; then
                  sudo systemctl enable docker || true
                  sudo systemctl start docker || true
                else
                  sudo service docker start || true
                fi
                sudo usermod -a -G docker "$(whoami)" || true
              else
                echo "Installing Docker via convenience script..."
                curl -fsSL https://get.docker.com -o get-docker.sh
                sudo sh get-docker.sh
                if command -v systemctl >/dev/null 2>&1; then
                  sudo systemctl enable docker || true
                  sudo systemctl start docker || true
                fi
              fi
            }

            ensure_compose() {
              if docker compose version >/dev/null 2>&1; then return; fi
              echo "docker compose not available; installing plugin binary..."
              VERSION="v2.24.7"
              ARCH="$(uname -m)"
              OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
              sudo mkdir -p /usr/local/lib/docker/cli-plugins
              sudo curl -fsSL "https://github.com/docker/compose/releases/download/${VERSION}/docker-compose-${OS}-${ARCH}" -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            }

            ensure_docker
            ensure_compose

            DOCKER_CMD="sudo docker"
            if docker ps >/dev/null 2>&1; then
              DOCKER_CMD="docker"
            fi

            echo "Logging into GHCR..."
            echo "$GHCR_TOKEN" | $DOCKER_CMD login ghcr.io -u "$GHCR_USERNAME" --password-stdin

            export IMAGE_NAME="${IMAGE_NAME}"
            export IMAGE_TAG="${IMAGE_TAG}"

            echo "Pulling image $IMAGE_NAME:$IMAGE_TAG..."
            set +e
            $DOCKER_CMD compose -f docker-compose.yml -f docker-compose.prod.yml pull web
            pull_status=$?
            if [ $pull_status -ne 0 ]; then
              echo "Pull failed for tag $IMAGE_TAG, falling back to latest..."
              export IMAGE_TAG="latest"
              $DOCKER_CMD compose -f docker-compose.yml -f docker-compose.prod.yml pull web || exit 1
            fi
            set -e

            echo "Starting stack..."
            $DOCKER_CMD compose -f docker-compose.yml -f docker-compose.prod.yml up -d

            echo "Pruning old images..."
            $DOCKER_CMD image prune -f
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ needs.build-and-push.result == 'success' && github.sha || 'latest' }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_READ_TOKEN || secrets.GHCR_TOKEN }}
          DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
          CERTBOT_EMAIL: ${{ secrets.CERTBOT_EMAIL }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
